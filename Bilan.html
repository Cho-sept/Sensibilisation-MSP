<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bilans — Attributif, Tirage de dé, Mesure, Usinage</title>
  <meta name="description" content="Bilans de contrôle: contrôle par attribut, tirage de dé, contrôle par la mesure et usinage (histogramme). Coller des données et obtenir des synthèses et graphiques." />
  <meta name="theme-color" content="#60a5fa" />
  <style>
    :root{
      --bg:#0b1020; --fg:#e5e7eb; --muted:#a3b1c6;
      --accent:#60a5fa; --ok:#22c55e; --err:#f87171;
      --panel:#141a2f; --border:#263046;
    }
    html,body{margin:0;background:var(--bg);color:var(--fg);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
    .wrap{max-width:1100px;margin:0 auto;padding:1rem}
    a.back, a.back:visited{color:#fff;text-decoration:none}
    a.back:hover, a.back:focus-visible{color:#e5e7eb;outline:2px solid #e5e7eb;outline-offset:2px}
    h1{font-size:1.4rem;margin:.5rem 0 1rem}
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:.75rem;padding:1rem}
    .muted{color:var(--muted)}
    .btn{padding:.65rem .85rem;border-radius:.5rem;border:1px solid var(--accent);color:var(--accent);background:transparent;cursor:pointer;font-weight:700}
    .btn.primary{background:var(--accent);color:#0b1020;border-color:var(--accent)}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .btn-row{display:flex;gap:.5rem;flex-wrap:wrap}
    textarea{
      width:95%;min-height:140px;background:#0f172a;color:var(--fg);
      border:1px solid #334155;border-radius:.5rem;padding:.7rem .8rem;resize:vertical
    }
    input[type="number"]{
      width:100%;padding:.55rem .6rem;border-radius:.5rem;border:1px solid #334155;background:#0f172a;color:var(--fg)
    }
    .grid{display:grid;gap:1rem;grid-template-columns: 1.1fr .9fr}
    @media (max-width:900px){ .grid{grid-template-columns:1fr} }
    .two{display:grid;gap:1rem;grid-template-columns:1fr 1fr}
    @media (max-width:700px){ .two{grid-template-columns:1fr} }

    /* Tabs */
    .tabs{display:flex;gap:.5rem;flex-wrap:wrap;margin:.5rem 0 1rem}
    .tab-btn{
      padding:.55rem .8rem;border-radius:.6rem;border:1px solid #334155;background:#0f172a;color:#cbd5e1;font-weight:700;cursor:pointer
    }
    .tab-btn[aria-selected="true"]{border-color:var(--accent);color:#0b1020;background:var(--accent)}
    .tab-panel{display:none}
    .tab-panel.active{display:block}

    /* KPI vertical */
    .kpi-list{display:grid;grid-template-columns:1fr;gap:.6rem;margin-top:.75rem}
    .kpi{background:rgba(96,165,250,.12);border:1px solid var(--border);border-radius:.6rem;padding:.6rem .7rem}
    .kpi h4{margin:0 0 .25rem;font-size:.95rem;color:#cbd5e1}
    .kpi .v{font-size:1.1rem;font-weight:800}

    /* Chart */
    .chart-wrap{margin-top:1rem}
    .chart-title{margin:0 0 .5rem;font-weight:800}
    .chart-legend{display:flex;gap:1rem;flex-wrap:wrap;margin:.5rem 0;color:var(--muted);font-size:.95rem}
    .legend-box{display:inline-flex;align-items:center;gap:.35rem}
    .lb{width:14px;height:14px;border-radius:3px;display:inline-block}
    .lb.hist{background:#1e3a8a}
    .lb.lsl{background:#f97316}
    .lb.gauss{background:linear-gradient(90deg,#c026d3 60%,#06b6d4)}
    .lb.theo{background:rgba(236,72,153,0.85);border:1.5px solid #e11d48;}
    .chart-svg{width:100%;height:auto;display:block}
    .chart-grid{stroke:#334155;stroke-width:1;opacity:.4}
    .bar-rect{fill:#1e3a8a;opacity:.85}
    .bar-rect.dice{fill:#06b6d4;opacity:.82}
    .limit-line{stroke:#f97316;stroke-width:2}
    .gauss-line{stroke:url(#dice-gauss);stroke-width:3;fill:none;}
    .gauss-line-shade{stroke:#c026d3;stroke-width:2;}
    .chart-text{fill:#cbd5e1;font:600 13px/1 system-ui,Segoe UI,Roboto}
    .stat-line{margin-top:.5rem;color:var(--muted)}
    .axis-label{fill:#cbd5e1;font-size:15px;font-weight:700;}
    .tick-label{fill:#cbd5e1;font-weight:600;}
    .theo-line{stroke:#ec4899;stroke-width:2;fill:none;stroke-dasharray:4,2;}

    @media (prefers-reduced-motion: reduce){
      *{transition:none !important;scroll-behavior:auto !important}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <p><a class="back" href="index.html">← Retour à l’accueil</a></p>
    <h1>Bilans — Attributif, Tirage de dé, Mesure, Usinage</h1>

    <div class="tabs" role="tablist" aria-label="Sélection du type de bilan">
      <button class="tab-btn" role="tab" id="tab-attr" aria-controls="panel-attr" aria-selected="true">Contrôle par attribut</button>
      <button class="tab-btn" role="tab" id="tab-meas" aria-controls="panel-meas" aria-selected="false">Contrôle par la mesure</button>
      <button class="tab-btn" role="tab" id="tab-dice" aria-controls="panel-dice" aria-selected="false">Tirage de dé</button>
      <button class="tab-btn" role="tab" id="tab-usi" aria-controls="panel-usi" aria-selected="false">Usinage (histogramme)</button>
    </div>

    <!-- ATTRIBUTIF -->
    <section id="panel-attr" class="tab-panel active panel" role="tabpanel" aria-labelledby="tab-attr">
      <h2 style="margin:0 0 .6rem;">Contrôle par attribut — Coller vos tirages</h2>
      <p class="muted" style="margin:.25rem 0 .75rem;">Collez une série de valeurs (une par ligne). Vous pouvez répéter l’opération plusieurs fois, les données s’ajoutent.</p>
      <div class="grid">
        <div class="panel">
          <label for="attrInput" style="display:block;font-weight:700;margin-bottom:.35rem;">Données</label>
          <textarea id="attrInput" placeholder="12&#10;3&#10;5&#10;10"></textarea>
          <div class="btn-row" style="margin-top:.5rem;">
            <button id="attrAdd" class="btn primary">Ajouter</button>
            <button id="attrClear" class="btn">Effacer tout</button>
          </div>
          <p id="attrMsg" class="muted" aria-live="polite" style="margin-top:.5rem;"></p>
        </div>
        <div class="panel">
          <h3 style="margin:0 0 .5rem;">Bilan</h3>
          <div class="kpi-list">
            <div class="kpi"><h4>n</h4><div class="v" id="attrN">0</div></div>
            <div class="kpi"><h4>Moyenne du nombre de tirages</h4><div class="v" id="attrMean">—</div></div>
            <div class="kpi"><h4>Min</h4><div class="v" id="attrMin">—</div></div>
            <div class="kpi"><h4>Max</h4><div class="v" id="attrMax">—</div></div>
            <div class="kpi"><h4>< 14</h4><div class="v" id="attrLt16">0</div></div>
            <div class="kpi"><h4>≥ 14</h4><div class="v" id="attrGe16">0</div></div>
          </div>
          <p class="muted" style="margin:.6rem 0 0;">Astuce: valeurs non numériques ignorées.</p>
        </div>
      </div>
    </section>

    <!-- DICE - TIRAGE DE DE -->
    <section id="panel-dice" class="tab-panel panel" role="tabpanel" aria-labelledby="tab-dice">
      <h2 style="margin:0 0 .6rem;">Tirage de dé — Coller l’historique des lancers</h2>
      <p class="muted" style="margin:.25rem 0 .75rem;">
        Collez les résultats de vos tirages de dé (1 à 6), un nombre par ligne, séparé par espace, virgule, tabulation.<br>
        Les décimales 0,5 sont acceptées (ex. 3.5).
      </p>
      <div class="panel" style="margin-bottom:1rem;">
        <label for="diceInput" style="display:block;font-weight:700;margin-bottom:.35rem;">Résultats</label>
        <textarea id="diceInput" placeholder="1&#10;6&#10;2.5&#10;5"></textarea>
        <div class="btn-row" style="margin-top:.5rem;">
          <button id="diceAdd" class="btn primary">Ajouter</button>
          <button id="diceClear" class="btn">Effacer tout</button>
        </div>
        <p id="diceMsg" class="muted" aria-live="polite" style="margin-top:.5rem;"></p>
      </div>
      <div class="panel chart-wrap">
        <h3 class="chart-title">Histogramme (pas 0,5) + courbe de Gauss théorique</h3>
        <div class="chart-legend">
          <span class="legend-box"><span class="lb hist" style="background:#06b6d4"></span>Histogramme</span>
          <span class="legend-box"><span class="lb gauss"></span>Gauss théorique</span>
        </div>
        <svg id="diceChart" class="chart-svg" viewBox="0 0 760 340" role="img" aria-label="Histogramme des tirages de dé"></svg>
        <div id="diceStats" class="stat-line"></div>
        <p id="diceHint" class="muted" style="margin-top:.25rem;"></p>
      </div>
    </section>

    <!-- MESURE (paires gauche;droite) -->
    <section id="panel-meas" class="tab-panel panel" role="tabpanel" aria-labelledby="tab-meas">
      <h2 style="margin:0 0 .6rem;">Contrôle par la mesure — Paires “gauche;droite”</h2>
      <p class="muted" style="margin:.25rem 0 .75rem;">Collez des lignes au format “gauche;droite” (ex: 10;5). Chaque collage ajoute aux données. Le bilan est calculé pour chaque population.</p>
      <div class="grid">
        <div class="panel">
          <label for="measInput" style="display:block;font-weight:700;margin-bottom:.35rem;">Données</label>
          <textarea id="measInput" placeholder="10;5&#10;12;3&#10;5;5"></textarea>
          <div class="btn-row" style="margin-top:.5rem;">
            <button id="measAdd" class="btn primary">Ajouter</button>
            <button id="measClear" class="btn">Effacer tout</button>
          </div>
          <p id="measMsg" class="muted" aria-live="polite" style="margin-top:.5rem;"></p>
        </div>
        <div class="panel">
          <div class="two">
            <div>
              <h3 style="margin:0 0 .5rem;">Contrôle selon logique attributive</h3>
              <div class="kpi-list">
                <div class="kpi"><h4>n</h4><div class="v" id="L_n">0</div></div>
                <div class="kpi"><h4>Moyenne du nombre de tirages</h4><div class="v" id="L_mean">—</div></div>
                <div class="kpi"><h4>Min</h4><div class="v" id="L_min">—</div></div>
                <div class="kpi"><h4>Max</h4><div class="v" id="L_max">—</div></div>
              </div>
            </div>
            <div>
              <h3 style="margin:0 0 .5rem;">Contrôle selon la mesure</h3>
              <div class="kpi-list">
                <div class="kpi"><h4>n</h4><div class="v" id="R_n">0</div></div>
                <div class="kpi"><h4>Moyenne du nombre de tirages</h4><div class="v" id="R_mean">—</div></div>
                <div class="kpi"><h4>Min</h4><div class="v" id="R_min">—</div></div>
                <div class="kpi"><h4>Max</h4><div class="v" id="R_max">—</div></div>
              </div>
            </div>
          </div>
          <p class="muted" style="margin:.6rem 0 0;">NB: Les lignes sans deux nombres valides sont ignorées.</p>
        </div>
      </div>
    </section>

    <!-- USINAGE (histogramme des valeurs collées) -->
    <section id="panel-usi" class="tab-panel panel" role="tabpanel" aria-labelledby="tab-usi">
      <h2 style="margin:0 0 .6rem;">Usinage — Coller des Ø validés et tracer l’histogramme</h2>
      <p class="muted" style="margin:.25rem 0 .75rem;">
        Collez une valeur par ligne.</strong>.
      </p>
      <div class="panel" style="margin-bottom:1rem;">
        <label for="usiInput" style="display:block;font-weight:700;margin-bottom:.35rem;">Diamètres (mm)</label>
        <textarea id="usiInput" placeholder="0.78&#10;0.72&#10;0.68"></textarea>
        <div class="btn-row" style="margin-top:.5rem%;">
          <button id="usiAdd" class="btn primary">Ajouter</button>
          <button id="usiClear" class="btn">Effacer tout</button>
        </div>
        <p id="usiMsg" class="muted" aria-live="polite" style="margin-top:.5rem;"></p>
      </div>

      <div class="panel chart-wrap">
        <h3 class="chart-title">Histogramme</h3>
        <div class="chart-legend">
          <span class="legend-box"><span class="lb hist"></span>Histogramme</span>
          <span class="legend-box"><span class="lb lsl"></span>LSL / USL</span>
        </div>
        <svg id="chart" class="chart-svg" viewBox="0 0 760 340" role="img" aria-label="Histogramme des diamètres"></svg>
        <div id="chartStats" class="stat-line"></div>
        <p id="chartHint" class="muted" style="margin-top:.25rem;"></p>
      </div>
    </section>
  </div>

  <script>
    // Utils
    const $ = (s, ctx=document)=>ctx.querySelector(s);
    const store = {
      get(k, f=null){ try{ return JSON.parse(localStorage.getItem(k)) ?? f; } catch { return f; } },
      set(k, v){ localStorage.setItem(k, JSON.stringify(v)); }
    };

    // Storage keys
    const K = {
      tab: 'bilans:tab',
      attr: 'bilans:attr:v1',
      dice: 'bilans:dice:v1',
      meas: 'bilans:meas:v1',
      usi:  'bilans:usi:data:v1',
      usiLim: 'bilans:usi:limits:v2'
    };

    // Tabs
    const tabs = [
      {btn: $('#tab-attr'), panel: $('#panel-attr'), key: 'attr'},
      {btn: $('#tab-dice'), panel: $('#panel-dice'), key: 'dice'},
      {btn: $('#tab-meas'), panel: $('#panel-meas'), key: 'meas'},
      {btn: $('#tab-usi'),  panel: $('#panel-usi'),  key: 'usi'}
    ];
    function setTab(key){
      tabs.forEach(t=>{
        const active = (t.key === key);
        t.btn.setAttribute('aria-selected', active?'true':'false');
        t.panel.classList.toggle('active', active);
      });
      store.set(K.tab, key);
    }
    tabs.forEach(t=> t.btn.addEventListener('click', ()=> setTab(t.key)));

    // Parsing helpers
    function toNum(s){
      if (typeof s !== 'string') return NaN;
      const v = s.replace(',', '.').trim();
      if (!v) return NaN;
      return Number(v);
    }
    function parseOnePerLine(text){
      // Sépare espaces, tab, virgules, sauts de ligne
      const vals = [];
      String(text||'').split(/[\s,;]+/).forEach(token=>{
        const v = toNum(token);
        if (isFinite(v)) vals.push(v);
      });
      return vals;
    }
    function parsePairs(text){
      const lines = String(text||'').split(/\r?\n/);
      const L = [], R = [];
      const rx = /(-?\d+(?:[.,]\d+)?)/g;
      for (const line of lines){
        const m = [...line.matchAll(rx)].map(x=>toNum(x[0])).filter(Number.isFinite);
        if (m.length >= 2){ L.push(m[0]); R.push(m[1]); }
      }
      return {L, R};
    }

    // Stats
    function stats(arr){
      const n = arr.length;
      if (!n) return { n:0, mean:null, min:null, max:null, lt16:0, ge16:0 };
      let s = 0, mn = arr[0], mx = arr[0], lt=0, ge=0;
      for (const v of arr){
        s += v;
        if (v < mn) mn = v;
        if (v > mx) mx = v;
        if (v < 14) lt++; else ge++;
      }
      return { n, mean: s/n, min: mn, max: mx, lt16: lt, ge16: ge };
    }
    function fmtMean(x){ return (x==null) ? '—' : (Math.round(x*100)/100).toFixed(2); }
    function fmtVal(x){ return (x==null) ? '—' : String(x); }
    function mean(arr){ return arr.reduce((s,v)=>s+v,0) / arr.length; }
    function sdSample(arr){
      if (arr.length < 2) return 0;
      const m = mean(arr);
      return Math.sqrt(arr.reduce((s,v)=>s + (v-m)*(v-m), 0) / (arr.length-1));
    }

    // ATTRIBUTIF
    const attrInput = $('#attrInput');
    const attrAdd   = $('#attrAdd');
    const attrClear = $('#attrClear');
    const attrMsg   = $('#attrMsg');
    const attrN   = $('#attrN');
    const attrMean= $('#attrMean');
    const attrMin = $('#attrMin');
    const attrMax = $('#attrMax');
    const attrLt16= $('#attrLt16');
    const attrGe16= $('#attrGe16');

    function getAttr(){ return store.get(K.attr, []); }
    function setAttr(arr){ store.set(K.attr, arr); renderAttr(); }
    function renderAttr(){
      const data = getAttr();
      const st = stats(data);
      attrN.textContent = st.n;
      attrMean.textContent = fmtMean(st.mean);
      attrMin.textContent = fmtVal(st.min);
      attrMax.textContent = fmtVal(st.max);
      attrLt16.textContent = st.lt16;
      attrGe16.textContent = st.ge16;
    }
    function addAttr(text){
      const vals = parseOnePerLine(text);
      if (vals.length===0){ attrMsg.textContent = 'Aucune valeur valide détectée.'; return; }
      const data = getAttr();
      data.push(...vals);
      setAttr(data);
      attrMsg.textContent = `${vals.length} valeur${vals.length>1?'s':''} ajoutée${vals.length>1?'s':''}. Total: ${data.length}.`;
      attrInput.value = '';
    }
    attrAdd.addEventListener('click', ()=> addAttr(attrInput.value));
    attrClear.addEventListener('click', ()=>{
      if (confirm('Effacer toutes les données attributives ?')) setAttr([]);
    });

    // -------------------
    // DICE / TIRAGE DE DE
    // -------------------
    const diceInput = $('#diceInput');
    const diceAdd   = $('#diceAdd');
    const diceClear = $('#diceClear');
    const diceMsg   = $('#diceMsg');
    const diceChart = $('#diceChart');
    const diceStats = $('#diceStats');
    const diceHint  = $('#diceHint');

    function getDice(){ return store.get(K.dice, []); }
    function setDice(arr){ store.set(K.dice, arr); renderDiceChart(); }

    // Arrondi au 0,5 le plus proche et bornage 1..6
    function roundToHalf(v){
      const r = Math.round(v * 2) / 2;
      return Math.min(6, Math.max(1, r));
    }

    function addDice(text){
      // Accepter 1..6 et 0,5: on normalise au 0,5 le plus proche
      let vals = parseOnePerLine(text).filter(Number.isFinite);
      vals = vals.map(roundToHalf).filter(n => n >= 1 && n <= 6);
      if (vals.length === 0){
        diceMsg.textContent = "Aucune valeur valide détectée (attendu: 1..6, pas 0,5).";
        return;
      }
      const prev = getDice();
      prev.push(...vals);
      setDice(prev);
      diceMsg.textContent = `${vals.length} valeur${vals.length>1?'s':''} ajoutée${vals.length>1?'s':''}. Total: ${prev.length}.`;
      diceInput.value = '';
    }
    diceAdd.addEventListener('click', ()=> addDice(diceInput.value));
    diceClear.addEventListener('click', ()=>{
      if (confirm('Effacer tout l’historique des tirages ?')) setDice([]);
    });

    // --------- DICE: Histogramme pas 0,5 + Gauss ---------
    function renderDiceChart(){
      const vals = getDice().filter(Number.isFinite);
      diceChart.innerHTML = '';
      const W = 760, H = 340, m = {l:60, r:16, t:20, b:40};
      const PW = W - m.l - m.r, PH = H - m.t - m.b;

      // Cadre
      diceChart.appendChild(el('rect', { x:m.l, y:m.t, width:PW, height:PH, fill:'none', stroke:'rgba(148,163,184,.32)' }));

      if (vals.length === 0){
        diceHint.textContent = 'Collez les résultats pour afficher la répartition (pas 0,5).';
        diceStats.textContent = '';
        return;
      } else {
        diceHint.textContent = '';
      }

      // Comptage sur pas 0,5 de 1.0 à 6.0 => 11 bins
      const binsHalf = new Array(11).fill(0); // indices 0..10 -> v = 1.0 + 0.5*i
      vals.forEach(v=>{
        const k = Math.round(v * 2); // 2..12
        const idx = k - 2;
        if (idx >= 0 && idx < binsHalf.length) binsHalf[idx]++;
      });
      const n = vals.length;
      const maxCount = Math.max(1, ...binsHalf);

      // Scales
      const stepW = PW / 11;
      const barW = stepW * 0.70;
      const scaleY = c => (c / maxCount) * (PH * 0.90);

      // Grille Y + labels
      const yTicks = Math.max(5, Math.ceil(maxCount/3));
      for (let i=0;i<=yTicks;i++){
        const frac = i/yTicks;
        const gy = m.t + PH - frac * PH;
        diceChart.appendChild(el('line', { x1:m.l, y1:gy, x2:m.l+PW, y2:gy, class:'chart-grid' }));
        const lbl = el('text', {x:m.l-10, y:gy+4, class:'chart-text', 'text-anchor':'end'});
        lbl.textContent = Math.round(frac*maxCount);
        diceChart.appendChild(lbl);
      }

      // Graduation X (pas 0,5)
      for (let i=0;i<11;i++){
        const v = 1 + i*0.5;
        const cx = m.l + (i+0.5)*stepW;
        const lbl = el('text',{ x:cx, y:H-10, class:'chart-text tick-label','text-anchor':'middle' });
        lbl.textContent = (Math.abs(v - Math.round(v)) < 1e-9) ? String(Math.round(v)) : v.toFixed(1);
        diceChart.appendChild(lbl);
      }

      // Barres histogramme
      for(let i=0;i<11;i++){
        const cx = m.l + i*stepW + (stepW-barW)/2;
        const bh = scaleY(binsHalf[i]);
        const cy = m.t + PH - bh;
        diceChart.appendChild(el('rect',{
          x:cx, y:cy, width: barW, height: bh,
          class:'bar-rect dice'
        }));
        if (binsHalf[i] > 0){
          diceChart.appendChild(el('text',{x:cx+barW/2, y:cy-6, 'text-anchor':'middle', fill:'#22d3ee', style:'font-weight:800'})).textContent = binsHalf[i];
        }
      }

      // Courbe de Gauss théorique sur 1..6 (mu=3.5, sigma=√35/12 ≈ 1.707)
      const mu = 3.5, sigma = Math.sqrt(35/12);
      let gaussMax=0, gaussVals=[];
      for(let i=0;i<=200;i++){
        const xx=1 + (i/200)*5;
        const dens = (1/(sigma*Math.sqrt(2*Math.PI))) * Math.exp(-0.5 * Math.pow((xx-mu)/sigma,2));
        gaussVals.push({x:xx, dens});
        if (dens>gaussMax) gaussMax=dens;
      }
      const scaleGauss = (dens) => dens/gaussMax*maxCount;

      // Dégradé SVG pour la gauss
      const grad = document.createElementNS("http://www.w3.org/2000/svg","linearGradient");
      grad.setAttribute("id","dice-gauss");
      grad.setAttribute("x1","0%"); grad.setAttribute("x2","100%");
      grad.innerHTML = `<stop offset="0%" stop-color="#c026d3"/><stop offset="100%" stop-color="#06b6d4"/>`;
      const defs = el('defs');
      defs.appendChild(grad);
      diceChart.appendChild(defs);

      // Path courbe
      let pathData='';
      gaussVals.forEach((pt,i)=>{
        const xg = m.l + (pt.x-1)/(6-1)*PW;
        const yg = m.t + PH - (scaleGauss(pt.dens)/maxCount)*(PH * 0.90);
        pathData += (i===0)?`M${xg},${yg}`:`L${xg},${yg}`;
      });
      diceChart.appendChild(el('path',{
        d:pathData,
        class:'gauss-line',
        style:'stroke:url(#dice-gauss);'
      }));

      // Labels axes
      const xl = el('text',{x:m.l+PW/2, y:H-3, class:'axis-label','text-anchor':'middle'});
      xl.textContent="Résultat du dé (pas 0,5)";
      diceChart.appendChild(xl);
      const yl = el('text',{x:20,y:m.t+PH/2,class:'axis-label','text-anchor':'middle',
        transform:`rotate(-90 20 ${m.t + PH/2})`
      });
      yl.textContent="Comptes";
      diceChart.appendChild(yl);

      // Stats synthétiques avec fréquences à pas 0,5
      const e = mean(vals), sd=sdSample(vals);
      let frqs = '';
      for(let i=0;i<11;i++){
        const v = 1 + i*0.5;
        const lab = (Math.abs(v - Math.round(v)) < 1e-9) ? String(Math.round(v)) : v.toFixed(1);
        const p = Math.round((binsHalf[i]/n)*100);
        frqs += `${lab}:${binsHalf[i]} (${isFinite(p)?p:0}%) `;
      }
      diceStats.textContent = `n = ${n} • moyenne = ${e.toFixed(3)} • écart-type = ${sd.toFixed(3)} • Fréquences (pas 0,5): ${frqs}`;
    }

    // MESURE
    const measInput = $('#measInput');
    const measAdd   = $('#measAdd');
    const measClear = $('#measClear');
    const measMsg   = $('#measMsg');
    const L_n=$('#L_n'), L_mean=$('#L_mean'), L_min=$('#L_min'), L_max=$('#L_max');
    const R_n=$('#R_n'), R_mean=$('#R_mean'), R_min=$('#R_min'), R_max=$('#R_max');

    function getMeas(){ return store.get(K.meas, {L:[], R:[]}); }
    function setMeas(obj){ store.set(K.meas, obj); renderMeas(); }
    function renderMeas(){
      const {L, R} = getMeas();
      const sL = stats(L), sR = stats(R);
      L_n.textContent = sL.n; L_mean.textContent = fmtMean(sL.mean); L_min.textContent = fmtVal(sL.min); L_max.textContent = fmtVal(sL.max);
      R_n.textContent = sR.n; R_mean.textContent = fmtMean(sR.mean); R_min.textContent = fmtVal(sR.min); R_max.textContent = fmtVal(sR.max);
    }
    function addMeas(text){
      const {L, R} = parsePairs(text);
      if (L.length===0){ measMsg.textContent = 'Aucune paire valide détectée.'; return; }
      const cur = getMeas();
      cur.L.push(...L); cur.R.push(...R);
      setMeas(cur);
      measMsg.textContent = `${L.length} paire${L.length>1?'s':''} ajoutée${L.length>1?'s':''}. Total: ${cur.L.length}/${cur.R.length}.`;
      measInput.value = '';
    }
    measAdd.addEventListener('click', ()=> addMeas(measInput.value));
    measClear.addEventListener('click', ()=>{
      if (confirm('Effacer toutes les données “mesure” ?')) setMeas({L:[],R:[]});
    });

    // USINAGE + Chart
    const usiInput = $('#usiInput');
    const usiAdd   = $('#usiAdd');
    const usiClear = $('#usiClear');
    const usiMsg   = $('#usiMsg');
    const chart = $('#chart');
    const chartStats = $('#chartStats');
    const chartHint = $('#chartHint');

    // Tolérances fixes
    const LSL = 0.497;
    const USL = 0.985;

    function getUsi(){ return store.get(K.usi, []); }
    function setUsi(arr){ store.set(K.usi, arr); renderChart(); }
    function getLimits(){
      return { lsl: LSL, usl: USL };
    }
    function addUsi(text){
      const vals = parseOnePerLine(text);
      if (vals.length===0){ usiMsg.textContent = 'Aucune valeur valide détectée.'; return; }
      const data = getUsi();
      data.push(...vals);
      setUsi(data);
      usiMsg.textContent = `${vals.length} valeur${vals.length>1?'s':''} ajoutée${vals.length>1?'s':''}. Total: ${data.length}.`;
      usiInput.value = '';
    }
    usiAdd.addEventListener('click', ()=> addUsi(usiInput.value));
    usiClear.addEventListener('click', ()=>{
      if (confirm('Effacer toutes les valeurs d’usinage ?')) setUsi([]);
    });

    // SVG helper
    function el(name, attrs={}){
      const e = document.createElementNS('http://www.w3.org/2000/svg', name);
      for (const k in attrs){ e.setAttribute(k, attrs[k]); }
      return e;
    }

    function renderChart(){
      const vals = getUsi().filter(Number.isFinite);
      const {lsl, usl} = getLimits();

      chart.innerHTML = '';
      const W = 760, H = 340, m = {l:55, r:20, t:20, b:40};
      const PW = W - m.l - m.r, PH = H - m.t - m.b;

      chart.appendChild(el('rect', { x:m.l, y:m.t, width:PW, height:PH, fill:'none', stroke:'rgba(148,163,184,.4)' }));

      if (vals.length === 0){
        chartHint.textContent = 'Collez des valeurs pour afficher l’histogramme.';
        chartStats.textContent = '';
        return;
      } else {
        chartHint.textContent = '';
      }

      // Domain X incluant LSL/USL
      const vMin = Math.min(...vals, (lsl??Infinity), (usl??Infinity));
      const vMax = Math.max(...vals, (lsl??-Infinity), (usl??-Infinity));
      const span = Math.max(0.0001, vMax - vMin);
      const pad = span * 0.08;
      const xMin = vMin - pad;
      const xMax = vMax + pad;

      const x = v => m.l + ((v - xMin) / (xMax - xMin)) * PW;
      const y = v => m.t + PH - v;

      // Binning adaptatif
      const n = vals.length;
      const binsCount = n >= 30 ? 12 : Math.max(5, Math.round(Math.sqrt(n)));
      const counts = new Array(binsCount).fill(0);
      for (const v of vals){
        let idx = Math.floor((v - xMin) / (xMax - xMin) * binsCount);
        if (idx < 0) idx = 0;
        if (idx >= binsCount) idx = binsCount - 1;
        counts[idx]++;
      }
      const maxCount = Math.max(1, ...counts);
      const scaleY = c => (c / maxCount) * (PH * 0.9);

      // Grille Y + labels
      const yTicks = 5;
      for (let i = 0; i <= yTicks; i++){
        const frac = i / yTicks;
        const gy = m.t + PH - frac * PH;
        chart.appendChild(el('line', { x1:m.l, y1:gy, x2:m.l + PW, y2:gy, class:'chart-grid' }));
        const lbl = el('text', { x:m.l - 8, y:gy + 4, class:'chart-text', 'text-anchor':'end' });
        lbl.textContent = Math.round(frac * maxCount);
        chart.appendChild(lbl);
      }

      // Graduation X
      const xTicks = 6;
      for (let i = 0; i <= xTicks; i++){
        const vx = xMin + i * (xMax - xMin) / xTicks;
        const gx = x(vx);
        chart.appendChild(el('line', { x1:gx, y1:m.t + PH, x2:gx, y2:m.t + PH + 6, stroke:'#94a3b8' }));
        const lbl = el('text', { x:gx, y:m.t + PH + 20, class:'chart-text', 'text-anchor':'middle' });
        lbl.textContent = vx.toFixed(3);
        chart.appendChild(lbl);
      }

      // Histogramme
      const binW = (xMax - xMin) / binsCount;
      const pixelBarW = PW / binsCount - 2;
      for (let i=0; i<binsCount; i++){
        const vx0 = xMin + i * binW;
        const c = counts[i];
        const bh = scaleY(c);
        chart.appendChild(el('rect', {
          x: x(vx0) + 1,
          y: y(bh),
          width: Math.max(1, pixelBarW),
          height: bh,
          class: 'bar-rect'
        }));
      }

      // Lignes LSL/USL fixes
      if (lsl!=null) chart.appendChild(el('line', { x1:x(lsl), y1:m.t, x2:x(lsl), y2:m.t+PH, class:'limit-line' }));
      if (usl!=null) chart.appendChild(el('line', { x1:x(usl), y1:m.t, x2:x(usl), y2:m.t+PH, class:'limit-line' }));

      // Labels axes
      const xl = el('text', { x:m.l + PW/2, y:H-8, class:'chart-text', 'text-anchor':'middle' });
      xl.textContent = 'Diamètre (mm)';
      chart.appendChild(xl);
      const yl = el('text', { x:14, y:m.t + PH/2, class:'chart-text', transform:`rotate(-90 14 ${m.t + PH/2})`, 'text-anchor':'middle' });
      yl.textContent = 'Comptes';
      chart.appendChild(yl);

      // Stats synthétiques
      const mu = mean(vals);
      const sd = sdSample(vals);
      chartStats.textContent = `n = ${n} • moyenne = ${mu.toFixed(3)} • écart-type (éch.) = ${sd.toFixed(3)} • LSL=${lsl??'—'} • USL=${usl??'—'}`;
    }

    // Init
    (function init(){
      const last = store.get(K.tab, 'attr');
      setTab(last);

      renderAttr();
      renderMeas();
      renderChart();
      renderDiceChart();
    })();
  </script>
</body>
</html>
