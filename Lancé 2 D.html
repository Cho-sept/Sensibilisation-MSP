<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Histogramme — 2 dés (sommes 2 à 12)</title>
  <meta name="theme-color" content="#60a5fa" />
  <style>
    :root{
      --bg:#0b1020; --fg:#e5e7eb; --muted:#a3b1c6;
      --accent:#60a5fa; --panel:#141a2f; --border:#263046;
      --bar:#1e3a8a; --grid:#334155;
    }
    html,body{margin:0;background:var(--bg);color:var(--fg);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
    .wrap{max-width:1200px;margin:0 auto;padding:1rem 1.2rem 2rem}

    /* Barre haute: retour index */
    .topbar{display:flex;gap:.6rem;align-items:center;margin-bottom:.5rem}
    a.back, a.back:visited{color:#fff;text-decoration:none}
    a.back:hover, a.back:focus-visible{color:#e5e7eb;outline:2px solid #e5e7eb;outline-offset:2px}

    .panel{background:var(--panel);border:1px solid var(--border);border-radius:.8rem;padding:1rem}
    .chart-wrap{padding:0}
    .chart-svg{width:100%;height:auto;display:block}
    .chart-grid{stroke:var(--grid);stroke-width:1;opacity:.4}
    .bar-rect{fill:var(--bar);opacity:.88}
    .chart-text{fill:#cbd5e1;font:600 13px/1 system-ui,Segoe UI,Roboto}
    .axis-label{fill:#cbd5e1;font-weight:800}
    .hint{color:var(--muted);text-align:center;margin:.5rem 0 0}

    /* Couche des boutons alignée pixel-par-pixel sous le graphe */
    .buttons-layer{
      position:relative;
      margin-top:1rem;
      /* largeur/alignement et padding sont réglés en JS pour coïncider avec la zone de tracé */
    }
    .round-btn{
      position:absolute; top:0;
      width:64px;height:64px;border-radius:9999px;
      background:transparent;border:2px solid var(--accent);
      color:var(--accent);font-weight:900;font-size:18px;
      display:flex;align-items:center;justify-content:center;
      text-align:center;cursor:pointer;user-select:none;
      transition:.12s ease;
    }
    .round-btn:hover{background:var(--accent);color:#0b1020;transform:translateY(-1px)}
    .round-btn:active{transform:translateY(0)}

    /* Reset centré sous les boutons */
    .controls{display:flex;justify-content:center;gap:.6rem;margin-top:1rem}
    .ctl-btn{
      padding:.6rem 1rem;border-radius:.55rem;border:2px solid var(--accent);
      background:transparent;color:var(--accent);font-weight:900;cursor:pointer;user-select:none;
      transition:.12s ease;
    }
    .ctl-btn:hover{background:var(--accent);color:#0b1020;transform:translateY(-1px)}
    .ctl-btn:active{transform:translateY(0)}

    @media (max-width:680px){
      .round-btn{width:58px;height:58px;font-size:17px}
    }
    @media (max-width:520px){
      .round-btn{width:52px;height:52px;font-size:16px}
    }

    @media (prefers-reduced-motion: reduce){
      *{transition:none !important;scroll-behavior:auto !important}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- Haut gauche: retour index -->
    <div class="topbar">
      <a class="back" href="index.html">← Retour à l’index</a>
    </div>

    <!-- GRAND HISTOGRAMME -->
    <section class="panel chart-wrap">
      <svg id="chart" class="chart-svg" viewBox="0 0 1000 520" role="img" aria-label="Histogramme des sommes de 2 dés (2..12)"></svg>
      <p id="hint" class="hint">Cliquez sur un bouton 2 à 12 pour incrémenter la barre correspondante.</p>
    </section>

    <!-- BOUTONS RONDS (2 à 12) ALIGNÉS EXACTEMENT SOUS LES BARRES -->
    <div id="btns" class="buttons-layer" role="group" aria-label="Ajouter une occurrence (somme de deux dés 2 à 12)"></div>

    <!-- RESET CENTRÉ SOUS LES BOUTONS -->
    <div id="ctrls" class="controls">
      <button id="resetBtn" class="ctl-btn" type="button">Reset</button>
    </div>
  </div>

  <script>
    // Utils
    const $ = (s, ctx=document)=>ctx.querySelector(s);
    const store = {
      get(k, f=null){ try{ return JSON.parse(localStorage.getItem(k)) ?? f; } catch { return f; } },
      set(k, v){ localStorage.setItem(k, JSON.stringify(v)); }
    };
    const K = { bins: 'hist:dice2:counts:v2' };

    // Sommes possibles de 2 dés: 2..12
    const SUMS = Array.from({length:11}, (_,i)=>i+2);
    const N = SUMS.length;

    // Données = comptes par somme
    function getCounts(){
      const a = store.get(K.bins, null);
      return Array.isArray(a) && a.length===N ? a : new Array(N).fill(0);
    }
    function setCounts(arr){ store.set(K.bins, arr); renderChart(); positionButtons(); }

    // SVG helper
    function el(name, attrs={}){
      const e = document.createElementNS('http://www.w3.org/2000/svg', name);
      for (const k in attrs){ e.setAttribute(k, attrs[k]); }
      return e;
    }

    // Rendu histogramme
    const chart = $('#chart');
    const hint = $('#hint');

    function renderChart(){
      const counts = getCounts();
      chart.innerHTML = '';
      // Marges (viewBox coord.)
      const m = { l:70, r:30, t:24, b:36 };
      const W = 1000, H = 520;
      const PW = W - m.l - m.r, PH = H - m.t - m.b;

      chart.appendChild(el('rect', { x:m.l, y:m.t, width:PW, height:PH, fill:'none', stroke:'rgba(148,163,184,.32)' }));

      const total = counts.reduce((s,v)=>s+v,0);
      hint.textContent = total===0
        ? 'Cliquez sur un bouton 2 à 12 pour incrémenter la barre correspondante.'
        : '';

      const maxC = Math.max(1, ...counts);

      // Grille Y
      const yTicks = Math.max(5, Math.ceil(maxC/3));
      for (let i=0;i<=yTicks;i++){
        const frac = i / yTicks;
        const gy = m.t + PH - frac * PH;
        chart.appendChild(el('line',{x1:m.l,y1:gy,x2:m.l+PW,y2:gy,class:'chart-grid'}));
        const lbl = el('text',{x:m.l-10, y:gy+4, class:'chart-text', 'text-anchor':'end'});
        lbl.textContent = Math.round(frac * maxC);
        chart.appendChild(lbl);
      }

      // Barres (11 colonnes)
      const stepW = PW / N;
      const barW = stepW * 0.70;
      const scaleY = c => (c/maxC) * (PH * 0.92);

      for (let i=0;i<N;i++){
        const c = counts[i];
        const bh = scaleY(c);
        const bx = m.l + i*stepW + (stepW - barW)/2;
        const by = m.t + PH - bh;

        chart.appendChild(el('rect', {
          x:bx, y:by, width:barW, height:bh, class:'bar-rect'
        }));

        if (c > 0){
          chart.appendChild(el('text', {
            x:bx + barW/2, y:by - 6, 'text-anchor':'middle', fill:'#93c5fd', style:'font-weight:800'
          })).textContent = c;
        }
      }

      // Axe Y uniquement
      const yl = el('text',{x:22,y:m.t+PH/2,class:'axis-label','text-anchor':'middle',
        transform:`rotate(-90 22 ${m.t+PH/2})`});
      yl.textContent = 'Comptes';
      chart.appendChild(yl);

      // Après rendu, positionner les boutons
      positionButtons();
      // Synchroniser le conteneur Reset en largeur avec le graphe
      syncResetToChart({ viewW: W, marginL: m.l, marginR: m.r });
    }

    // Boutons ronds
    const btns = $('#btns');
    function buildButtons(){
      btns.innerHTML = '';
      SUMS.forEach((v, i)=>{
        const btn = document.createElement('button');
        btn.className = 'round-btn';
        btn.type = 'button';
        btn.textContent = String(v);
        btn.setAttribute('data-index', i);
        btn.setAttribute('aria-label', `Ajouter ${v}`);
        btn.addEventListener('click', ()=>{
          const arr = getCounts();
          arr[i] = (arr[i]||0) + 1;
          setCounts(arr);
        });
        btns.appendChild(btn);
      });
      // Initial placement
      positionButtons();
    }

    // Positionnement pixel-par-pixel des boutons sur les centres des barres
    function positionButtons(){
      const rect = chart.getBoundingClientRect();
      const svgWidthPx = rect.width;
      const viewW = 1000, marginL = 70, marginR = 30;

      // Pixels des marges (convertis depuis viewBox)
      const leftPx = svgWidthPx * (marginL / viewW);
      const rightPx = svgWidthPx * (marginR / viewW);
      const plotW = svgWidthPx - leftPx - rightPx;

      // Caler le conteneur en largeur et centrage
      btns.style.width = svgWidthPx + 'px';
      btns.style.marginLeft = 'auto';
      btns.style.marginRight = 'auto';
      btns.style.paddingLeft = '0';
      btns.style.paddingRight = '0';

      const buttons = Array.from(btns.children);
      if (buttons.length === 0) return;

      // Mesurer la hauteur la plus grande (pour fixer la hauteur du conteneur)
      let maxH = 0;
      for (const b of buttons) maxH = Math.max(maxH, b.getBoundingClientRect().height);
      btns.style.height = Math.ceil(maxH) + 'px';

      const stepWpx = plotW / N;

      // Positionner chaque bouton au centre de sa colonne
      buttons.forEach((b, i)=>{
        const bw = b.getBoundingClientRect().width;
        const centerX = leftPx + (i + 0.5) * stepWpx;
        const left = centerX - bw / 2;
        b.style.left = left + 'px';
      });
    }

    // Reset centré sous les boutons
    const ctrls = $('#ctrls');
    const resetBtn = $('#resetBtn');
    resetBtn.addEventListener('click', ()=>{
      if (!confirm('Effacer tous les comptes ?')) return;
      setCounts(new Array(N).fill(0));
    });

    // Aligner le conteneur du reset (largeur/padding) avec le graphe
    function syncResetToChart({ viewW, marginL, marginR }){
      const rect = chart.getBoundingClientRect();
      const svgWidthPx = rect.width;
      const leftPx = svgWidthPx * (marginL / viewW);
      const rightPx = svgWidthPx * (marginR / viewW);

      ctrls.style.width = svgWidthPx + 'px';
      ctrls.style.marginLeft = 'auto';
      ctrls.style.marginRight = 'auto';
      ctrls.style.paddingLeft = leftPx + 'px';
      ctrls.style.paddingRight = rightPx + 'px';
    }

    // Init + resize
    buildButtons();
    renderChart();
    window.addEventListener('resize', ()=>{
      positionButtons();
      syncResetToChart({ viewW:1000, marginL:70, marginR:30 });
    });
  </script>
</body>
</html>
